/*
 *  ======== HDC2080.c ========
 *  HDC2080 APIs for initialization and use of the HDC2080 peripheral
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool for
 *  the TI Sensors in this application.
 */

#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stm8l15x_conf.h>
#include <HDC2080.h>
#include <mcu.h>



/*
 *  ======== HDC2080_config ========
 * Configure device with current settings.
 */
void HDC2080_config(HDC2080_Handle sensor)
{
    uint8_t txBuf[9];

    /* Initialize the bus containing this sensor */
    mcu_i2cInit(sensor->busId);

    /* Write all eight registers 0x07 -> 0x0E in one transfer */
    txBuf[0] = HDC2080_INT_CONFIG;
    memcpy(&txBuf[1], &sensor->intConfig, 8);
    mcu_i2cTransfer(sensor->busId, sensor->devAddr,
                    txBuf, 9, NULL, 0);

    /* Write Measurement Configuration Register last (0x0F) */
    txBuf[0] = HDC2080_MEAS_CONFIG;
    if (sensor->config & HDC2080_CONFIG_AMM_MASK)
    {
        txBuf[1] = sensor->measConfig | HDC2080_MEAS_CONFIG_MEAS_TRIG_START;
    }
    else
    {
        txBuf[1] = sensor->measConfig;
    }
    mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 2, NULL, 0);
}

/*
 *  ======== HDC2080_read ========
 *  Read temperature and humidity registers
 */
void HDC2080_read(HDC2080_Handle sensor, uint32_t result[])
{
    uint8_t txBuf[2];
    uint8_t rxBuf[4] = {0};

    /* If AMM is disabled trigger conversion */
    if (!(sensor->config & HDC2080_CONFIG_AMM_MASK))
    {
        /* Reset AMM to start measurement */
        txBuf[0] = HDC2080_MEAS_CONFIG;
        txBuf[1] = sensor->measConfig | HDC2080_MEAS_CONFIG_MEAS_TRIG_START;
        mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 2, NULL, 0);

        /* Wait for conversion to complete */
        mcu_msWait(sensor->convWaitHum);
    }

    /* Read registers, LOW and HIGH bytes */
    txBuf[0] = HDC2080_TEMP_LOW;
    mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 1, rxBuf, 4);

    result[0] = (uint16_t)rxBuf[1] << 8 | rxBuf[0];
    result[1] = (uint16_t)rxBuf[3] << 8 | rxBuf[2];
}

/*
 *  ======== HDC2080_humRead ========
 *  Read humidity register
 */
uint16_t HDC2080_humRead(HDC2080_Handle sensor)
{
    uint8_t txBuf[2];
    uint8_t rxBuf[2] = {0};
    uint32_t hum;

    /* If AMM is disabled trigger conversion */
    if (!(sensor->config & HDC2080_CONFIG_AMM_MASK))
    {
        /* Reset AMM to start measurement */
        txBuf[0] = HDC2080_MEAS_CONFIG;
        txBuf[1] = sensor->measConfig | HDC2080_MEAS_CONFIG_MEAS_TRIG_START;
        mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 2, NULL, 0);

        /* Wait for conversion to complete */
        mcu_msWait(sensor->convWaitHum);
    }

    /* Read humidity registers, LOW and HIGH bytes */
    txBuf[0] = HDC2080_HUM_LOW;
    mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 1, rxBuf, 2);

    hum = (uint16_t)rxBuf[1] << 8 | rxBuf[0];

    return (hum);
}

/*
 *  ======== HDC2080_humToFloatRelative ========
 *  Convert humidity to a relative percentage
 */
float HDC2080_humToFloatRelative(uint16_t x)
{
    return ((float)x * (100.0f / 65536.0f));
}

/*
 *  ======== HDC2080_humToIntRelative ========
 *  Convert raw humidity register value to the relative humidity rounded
 *  to the nearest whole number; a range of 0 to 100.
 */
uint32_t HDC2080_humToIntRelative(uint16_t x)
{
    /* round relative humidity to nearest whole number */
    return ((25 * (uint32_t)x + 0x2000) >> 14);
}

/*
 *  ======== HDC2080_humToPermille ========
 *  Convert raw humidity register value to integral value equal to
 *  ten times the relative humidity
 */
uint32_t HDC2080_humToPermille(uint16_t x)
{
    /* compute (relative humidity * 10) and truncate to a whole number */
    return ((125 * (uint32_t)x) >> 13);
}

/*
 *  ======== HDC2080_tempRead ========
 *  Read temperature register
 */
uint16_t HDC2080_tempRead(HDC2080_Handle sensor)
{
    uint8_t txBuf[2];
    uint8_t rxBuf[2] = {0};
    uint16_t tmp;

    /* If AMM is disabled trigger conversion */
    if (!(sensor->config & HDC2080_CONFIG_AMM_MASK))
    {
        /* Reset AMM to start measurement */
        txBuf[0] = HDC2080_MEAS_CONFIG;
        txBuf[1] = sensor->measConfig | HDC2080_MEAS_CONFIG_MEAS_TRIG_START;
        mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 2, NULL, 0);

        /* Wait for conversion to complete */
        mcu_msWait(sensor->convWaitTemp);
    }

    /* Read temperature registers, LOW and HIGH */
    txBuf[0] = HDC2080_TEMP_LOW;
    mcu_i2cTransfer(sensor->busId, sensor->devAddr, txBuf, 1, rxBuf, 2);

    tmp = (uint16_t)rxBuf[1] << 8 | rxBuf[0];

    return (tmp);
}

/*
 *  ======== HDC2080_tempToFloatCelsius ========
 *  Convert temperature to celsius
 */
float HDC2080_tempToFloatCelsius(uint16_t x)
{
    return ((float)x * (165.0f / 65536.0f) - 40.0f);
}

/*
 *  ======== HDC2080_tempToIntCelsius ========
 *  Convert raw temperature register value to whole degrees Celsius
 */
int32_t HDC2080_tempToIntCelsius(uint16_t raw)
{
    int32_t x;

    /* add bias so truncation rounds to the nearest whole value */
    x = ((int32_t)raw * 165 + 32768) >> 16;

    /* shift result so result is Celsius */
    return (x - 40);
}

/*
 *  ======== HDC2080_tempToMilliCelsius ========
 *  Convert raw temperature register value to milli-degrees Celsius
 */
int32_t HDC2080_tempToMilliCelsius(uint16_t x)
{
    /* Scale conversion for milli-degrees and truncate rather than round */
    return ((20625 * (int32_t)x) >> 13) - 40000;
}
